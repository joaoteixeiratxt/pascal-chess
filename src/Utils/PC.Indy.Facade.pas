
// DISCLAIMER: Unit fully generated by AI

unit PC.Indy.Facade;

interface

uses
  System.Classes, System.SysUtils, System.NetEncoding,
  IdHTTP, IdSSLOpenSSL, IdGlobal, IdHeaderList;

type
  EHttpClientException = class(Exception);

  IHttpResponse = interface
    ['{D8746E06-0A63-4C9A-9B2E-9A1B2E87A3D1}']
    function StatusCode: Integer;
    function BodyAsString: string;
    function Headers: TStrings;
  end;

  IHttpClient = interface
    ['{2D5D2B6B-7B35-4B6C-8A65-84E3D0FDABF2}']
    procedure SetBaseUrl(const ABaseUrl: string);
    procedure SetTimeouts(ConnectTimeoutMs, ReadTimeoutMs: Integer);
    procedure SetDefaultHeader(const Name, Value: string);
    procedure ClearDefaultHeaders;
    function Get(const AUrl: string; AHeaders: TStrings = nil): IHttpResponse;
    function Post(const AUrl, AContent: string;
      const AContentType: string = 'application/json';
      AHeaders: TStrings = nil): IHttpResponse;
    function PostStream(const AUrl: string; AStream: TStream;
      const AContentType: string; AHeaders: TStrings = nil): IHttpResponse;
    function Delete(const AUrl: string; AHeaders: TStrings = nil): IHttpResponse;
  end;

function NewIndyHttpClient: IHttpClient;

implementation

type
  THttpResponse = class(TInterfacedObject, IHttpResponse)
  private
    FStatus: Integer;
    FBody: string;
    FHeaders: TStringList;
  public
    constructor Create(AStatus: Integer; const ABody: string; AHeaders: TIdHeaderList);
    destructor Destroy; override;
    function StatusCode: Integer;
    function BodyAsString: string;
    function Headers: TStrings;
  end;

  TIndyHttpClient = class(TInterfacedObject, IHttpClient)
  private
    FHTTP: TIdHTTP;
    FSSL: TIdSSLIOHandlerSocketOpenSSL;
    FBaseUrl: string;
    FDefaultHeaders: TStringList;
    function BuildUrl(const AUrl: string): string;
    procedure ApplyHeaders(Extra: TStrings);
    procedure ResetResponse(out Code: Integer; out Body: string);
  public
    constructor Create;
    destructor Destroy; override;
    procedure SetBaseUrl(const ABaseUrl: string);
    procedure SetTimeouts(ConnectTimeoutMs, ReadTimeoutMs: Integer);
    procedure SetDefaultHeader(const Name, Value: string);
    procedure ClearDefaultHeaders;
    function Get(const AUrl: string; AHeaders: TStrings = nil): IHttpResponse;
    function Post(const AUrl, AContent: string;
      const AContentType: string = 'application/json';
      AHeaders: TStrings = nil): IHttpResponse;
    function PostStream(const AUrl: string; AStream: TStream;
      const AContentType: string; AHeaders: TStrings = nil): IHttpResponse;
    function Delete(const AUrl: string; AHeaders: TStrings = nil): IHttpResponse;
  end;

function NewIndyHttpClient: IHttpClient;
begin
  Result := TIndyHttpClient.Create;
end;

constructor THttpResponse.Create(AStatus: Integer; const ABody: string; AHeaders: TIdHeaderList);
begin
  inherited Create;
  FStatus := AStatus;
  FBody := ABody;
  FHeaders := TStringList.Create;
  if AHeaders <> nil then
    FHeaders.Text := AHeaders.Text;
end;

destructor THttpResponse.Destroy;
begin
  FHeaders.Free;
  inherited;
end;

function THttpResponse.StatusCode: Integer;
begin
  Result := FStatus;
end;

function THttpResponse.BodyAsString: string;
begin
  Result := FBody;
end;

function THttpResponse.Headers: TStrings;
begin
  Result := FHeaders;
end;

constructor TIndyHttpClient.Create;
begin
  inherited;
  FHTTP := TIdHTTP.Create(nil);
  FSSL := TIdSSLIOHandlerSocketOpenSSL.Create(nil);
  FDefaultHeaders := TStringList.Create;
  FSSL.SSLOptions.Method := sslvTLSv1_2;
  FSSL.SSLOptions.Mode := sslmClient;
  FHTTP.IOHandler := FSSL;
  FHTTP.HandleRedirects := True;
  FHTTP.ProtocolVersion := pv1_1;
  FHTTP.ReadTimeout := 30000;
  FHTTP.ConnectTimeout := 15000;
  FHTTP.Request.UserAgent := 'IndyFacade/1.0';
  FHTTP.Request.Accept := 'application/json, text/plain, */*';
  FHTTP.Request.AcceptCharSet := 'utf-8';
  FHTTP.Request.Connection := 'keep-alive';
end;

destructor TIndyHttpClient.Destroy;
begin
  FDefaultHeaders.Free;
  FSSL.Free;
  FHTTP.Free;
  inherited;
end;

procedure TIndyHttpClient.SetBaseUrl(const ABaseUrl: string);
begin
  FBaseUrl := ABaseUrl.TrimRight(['/']);
end;

procedure TIndyHttpClient.SetTimeouts(ConnectTimeoutMs, ReadTimeoutMs: Integer);
begin
  if ConnectTimeoutMs > 0 then
    FHTTP.ConnectTimeout := ConnectTimeoutMs;
  if ReadTimeoutMs > 0 then
    FHTTP.ReadTimeout := ReadTimeoutMs;
end;

procedure TIndyHttpClient.SetDefaultHeader(const Name, Value: string);
begin
  if Name = '' then Exit;
  FDefaultHeaders.Values[Name] := Value;
end;

procedure TIndyHttpClient.ClearDefaultHeaders;
begin
  FDefaultHeaders.Clear;
end;

function TIndyHttpClient.BuildUrl(const AUrl: string): string;
begin
  if (FBaseUrl <> '') and not AUrl.ToLower.StartsWith('http') then
    Result := FBaseUrl + '/' + AUrl.TrimLeft(['/'])
  else
    Result := AUrl;
end;

procedure TIndyHttpClient.ApplyHeaders(Extra: TStrings);
var
  i: Integer;
begin
  FHTTP.Request.CustomHeaders.Clear;
  for i := 0 to FDefaultHeaders.Count - 1 do
    if FDefaultHeaders.Names[i] <> '' then
      FHTTP.Request.CustomHeaders.Values[FDefaultHeaders.Names[i]] :=
        FDefaultHeaders.ValueFromIndex[i];
  if Extra <> nil then
    for i := 0 to Extra.Count - 1 do
      if Extra.Names[i] <> '' then
        FHTTP.Request.CustomHeaders.Values[Extra.Names[i]] :=
          Extra.ValueFromIndex[i];
end;

procedure TIndyHttpClient.ResetResponse(out Code: Integer; out Body: string);
begin
  if (FHTTP.Response <> nil) then
    Code := FHTTP.Response.ResponseCode
  else
    Code := 0;
  Body := '';
end;

function TIndyHttpClient.Get(const AUrl: string; AHeaders: TStrings): IHttpResponse;
var
  LUrl: string;
  LCode: Integer;
  LBody: string;
  LStream: TStringStream;
begin
  LUrl := BuildUrl(AUrl);
  ApplyHeaders(AHeaders);
  ResetResponse(LCode, LBody);
  LStream := TStringStream.Create('', TEncoding.UTF8);
  try
    try
      FHTTP.Get(LUrl, LStream);
      LStream.Position := 0;
      LBody := LStream.DataString;
      LCode := FHTTP.Response.ResponseCode;
    except
      on E: EIdHTTPProtocolException do
      begin
        LCode := E.ErrorCode;
        LBody := E.ErrorMessage;
      end;
      on E: Exception do
        raise EHttpClientException.CreateFmt('GET failed: %s', [E.Message]);
    end;
    Result := THttpResponse.Create(LCode, LBody, FHTTP.Response.RawHeaders);
  finally
    LStream.Free;
  end;
end;

function TIndyHttpClient.Post(const AUrl, AContent, AContentType: string;
  AHeaders: TStrings): IHttpResponse;
var
  LStream: TStringStream;
begin
  LStream := TStringStream.Create(AContent, TEncoding.UTF8);
  try
    Result := PostStream(AUrl, LStream, AContentType, AHeaders);
  finally
    LStream.Free;
  end;
end;

function TIndyHttpClient.PostStream(const AUrl: string; AStream: TStream;
  const AContentType: string; AHeaders: TStrings): IHttpResponse;
var
  LUrl: string;
  LCode: Integer;
  LBody: string;
  LRespStream: TStringStream;
begin
  LUrl := BuildUrl(AUrl);
  ApplyHeaders(AHeaders);
  ResetResponse(LCode, LBody);
  if AContentType <> '' then
    FHTTP.Request.ContentType := AContentType;
  LRespStream := TStringStream.Create('', TEncoding.UTF8);
  try
    try
      AStream.Position := 0;
      FHTTP.Post(LUrl, AStream, LRespStream);
      LRespStream.Position := 0;
      LBody := LRespStream.DataString;
      LCode := FHTTP.Response.ResponseCode;
    except
      on E: EIdHTTPProtocolException do
      begin
        LCode := E.ErrorCode;
        LBody := E.ErrorMessage;
      end;
      on E: Exception do
        raise EHttpClientException.CreateFmt('POST failed: %s', [E.Message]);
    end;
    Result := THttpResponse.Create(LCode, LBody, FHTTP.Response.RawHeaders);
  finally
    LRespStream.Free;
  end;
end;

function TIndyHttpClient.Delete(const AUrl: string; AHeaders: TStrings): IHttpResponse;
var
  LUrl: string;
  LCode: Integer;
  LBody: string;
begin
  LUrl := BuildUrl(AUrl);
  ApplyHeaders(AHeaders);
  ResetResponse(LCode, LBody);
  try
    try
      LBody := FHTTP.Delete(LUrl);
      LCode := FHTTP.Response.ResponseCode;
    except
      on E: EIdHTTPProtocolException do
      begin
        LCode := E.ErrorCode;
        LBody := E.ErrorMessage;
      end;
      on E: Exception do
        raise EHttpClientException.CreateFmt('DELETE failed: %s', [E.Message]);
    end;
    Result := THttpResponse.Create(LCode, LBody, FHTTP.Response.RawHeaders);
  except
    raise;
  end;
end;

end.

